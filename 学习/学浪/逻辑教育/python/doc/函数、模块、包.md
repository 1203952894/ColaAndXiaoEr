# 函数模块和包

> author: Cola
> Time :  2022.7.27

![](https://raw.githubusercontent.com/1203952894/macminiPicGo/main/20220817150548.png)

**目录结构：**

> - Python 函数
> - 模块
> - 包

## Python函数

**目录结构：**

> - 概述
> - 定义格式
> - 调用
> - 参数传递
> - 参数
> - 匿名函数 Lambda
> - return 语句
> - 变量作用域

- **概述：**

>
> 函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。
>
> 函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，
>
> 比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。

- **定义格式：**

> 你可以定义一个由自己想要功能的函数，以下是简单的规则：
>
>> 1. 函数代码块以 **def** 关键词开头，后接函数标识符名称和圆括号 **()** 。
>> 2. 任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。
>> 3. 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。
>> 4. 函数内容以冒号起始，并且缩进。
>> 5. **return [表达式]** 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。
>>

**语法：**

```python
def functionname( parameters ):
   "函数_文档字符串"
   function_suite
   return [expression]
```

默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。

以下为一个简单的Python函数，它将一个字符串作为传入参数，再打印到标准显示设备上。

```python
def printme( str ):
   "打印传入的字符串到标准显示设备上"
   print str
   return
```

- **调用：**

>
> 定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。
>
> 这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从Python提示符执行。
>
> 如下实例调用了printme（）函数：

```python
# 定义函数
def printme( str ):
   "打印任何传入的字符串"
   print str
   return
 
# 调用函数
printme("我要调用用户自定义函数!")
printme("再次调用同一函数")
```

以上实例输出结果：

>
> ```
> 我要调用用户自定义函数!
> 再次调用同一函数
> ```

- **参数传递：**

> 在 python 中，类型属于对象，变量是没有类型的：

```python
a=[1,2,3]
 
a="Runoob"
```

以上代码中，**[1,2,3]** 是 List 类型，**"Runoob"** 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。

**可更改(mutable)与不可更改(immutable)对象:**

> 在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。


* **不可变类型：** 变量赋值 **a=5** 后再赋值  **a=10** ，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。
* **可变类型：** 变量赋值 **la=[1,2,3,4]** 后再赋值 **la[2]=5** 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。

**python 函数的参数传递：**


* **不可变类型：** 类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。
* **可变类型：** 类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响

python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。

> ### python 传不可变对象实例

```python
def ChangeInt( a ):
    a = 10
 
b = 2
ChangeInt(b)
print b # 结果是 2
```

实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。

> ### 传可变对象实例

```python
def changeme( mylist ):
   "修改传入的列表"
   mylist.append([1,2,3,4])
   print "函数内取值: ", mylist
   return
 
# 调用changeme函数
mylist = [10,20,30]
changeme( mylist )
print "函数外取值: ", mylist
```

实例中传入函数的和在末尾添加新内容的对象用的是同一个引用，故输出结果如下：

```python
函数内取值:  [10, 20, 30, [1, 2, 3, 4]]
函数外取值:  [10, 20, 30, [1, 2, 3, 4]]
```

- **参数：**

> 以下是调用函数时可使用的正式参数类型：
>
>> * 必备参数
>> * 关键字参数
>> * 默认参数
>> * 不定长参数
>>

> **必备参数:** 
>
> 必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。
>
> 调用printme()函数，你必须传入一个参数，不然会出现语法错误：

```python
#可写函数说明
def printme( str ):
   "打印任何传入的字符串"
   print str
   return
 
#调用printme函数
printme()
```



以上实例输出结果：

```python
Traceback (most recent call last):
  File "test.py", line 11, in <module>
    printme()
TypeError: printme() takes exactly 1 argument (0 given)
```

>
> **关键字 参数：**
>
> 关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。
>
> 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。
>
> 以下实例在函数 printme() 调用时使用参数名：

```python
def printme( str ):
   "打印任何传入的字符串"
   print str
   return
 
#调用printme函数
printme( str = "My string")
```

以上实例输出结果：

```python
My string
```

下例能将关键字参数顺序不重要展示得更清楚：

```python
def printinfo( name, age ):
   "打印任何传入的字符串"
   print "Name: ", name
   print "Age ", age
   return
 
#调用printinfo函数
printinfo( age=50, name="miki" )
```

以上实例输出结果：

```python
Name:  miki
Age  50
```


> **默认参数：**
>
> 调用函数时，默认参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入：

```python
def printinfo( name, age = 35 ):
   "打印任何传入的字符串"
   print "Name: ", name
   print "Age ", age
   return
 
#调用printinfo函数
printinfo( age=50, name="miki" )
printinfo( name="miki" )
```

以上实例输出结果：

```python
Name:  miki
Age  50
Name:  miki
Age  35
```


> **不定长 参数：**
>
> 你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：

```python
def functionname([formal_args,] *var_args_tuple ):
   "函数_文档字符串"
   function_suite
   return [expression]
```

加了星号（*）的变量名会存放所有未命名的变量参数。不定长参数实例如下：

```python
def printinfo( arg1, *vartuple ):
   "打印任何传入的参数"
   print "输出: "
   print arg1
   for var in vartuple:
      print var
   return
 
# 调用printinfo 函数
printinfo( 10 )
printinfo( 70, 60, 50 )
```

以上实例输出结果：

```python
输出:
10
输出:
70
60
50
```

- **匿名函数 Lambda：**

> python 使用 lambda 来创建匿名函数。
>
>> * lambda只是一个表达式，函数体比def简单很多。
>> * lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。
>> * ambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。
>> * 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。
>>

> ### 语法: lambda函数的语法只包含一个语句，如下：

```python
lambda [arg1 [,arg2,.....argn]]:expression
```

如下实例：

```python
sum = lambda arg1, arg2: arg1 + arg2
 
# 调用sum函数
print "相加后的值为 : ", sum( 10, 20 )
print "相加后的值为 : ", sum( 20, 20 )
```

以上实例输出结果：

```python
相加后的值为 :  30
相加后的值为 :  40
```

- **return语句：**

> return语句[表达式]退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，下例便告诉你怎么做：

```python
def sum( arg1, arg2 ):
   # 返回2个参数的和."
   total = arg1 + arg2
   print "函数内 : ", total
   return total
 
# 调用sum函数
total = sum( 10, 20 )
```

以上实例输出结果：

```python
函数内 :  30
```

- **变量作用域：**

>
> 一个程序的所有的变量并不是在哪个位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。
>
> 变量的作用域决定了在哪一部分程序你可以访问哪个特定的变量名称。两种最基本的变量作用域如下：

>
> 定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。
>
> 局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：

```python
total = 0 # 这是一个全局变量
# 可写函数说明
def sum( arg1, arg2 ):
   #返回2个参数的和."
   total = arg1 + arg2 # total在这里是局部变量.
   print "函数内是局部变量 : ", total
   return total
 
#调用sum函数
sum( 10, 20 )
print "函数外是全局变量 : ", total
```

以上实例输出结果：

```python
函数内是局部变量 :  30
函数外是全局变量 :  0
```

## 模块

**目录结构：**

> - 模块的介绍
> - 模块的分类
> - 创建模块
> - 模块的使用
> - 模块的下载（pip）
> - dir（）函数
> - Python中name属性

- **模块的介绍:**

>
> 变量：存放数据
>
> 函数：封装代码块
>
> 模块：模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py，封装具有相似功能的多个函数。一个Python文件就是一个模块（模块名就是一个文件名，例如：text.py , 那么这个模块名是text）
>
> 注意：当python文件作为一个模块的时候 ， 模块名就是文件名 ， 并且不带文件后缀。

- **模块的分类:**

> 模块分为三类，分别是：内置模块，第三方模块和自定义模块
>
>> 1. **内置模块（标准库）**
>> 2. **第三方模块**
>> 3. **自定义模块**
>>

**内置模块（标准库）:  Python自带的， 需要使用时 ， 进行导入即可。**

**第三方模块 : 这种模块时其他技术人员开发的 ， 那么我们需要使用的时候，需要进行一个下载该模块，然后才可以进行导入操作**

**自定义模块: 这个就是自己根据需要来进行自定的模块。**

- **创建模块:**

>
> 如需创建模块，只需将所需代码保存在文件扩展名为 `.py` 的文件中：

**示例：
在hello.py文件中保存代码**

```python
def hello():
    print("hello world")
```

- **模块的使用:**

> **import语句**

语法：

```python
import 模块名 # 导入模块
模块名.函数（变量）	#调用模块内的函数（变量）
```

import 语句可以一次导入多个包，但建议在导入模块时一个一个的导入，这使我们在阅读代码时看的更加清晰

示例：

```python
import hello # 导入模块
hello.hello()  # 调用模块功能
```

注意：

1. 无论执行了多少次import，模块都只能导入一次，以防止重复引用。
2. 引入任何模块时(包括自定义模块)，无需添加.py后缀。
3. Python解释器在使用import语句时找到相应的文件。

这涉及到Python的搜索路径。搜索路径由一系列目录名组成，Python解释器依次从这些目录中找到引入的模块。

> ### from····import····语句

Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中。

语法：

```python
from 模块名 import 函数  # 导入模块中的功能
函数（）  #功能函数调用
```

通过from····import····语句导入的模块功能，只能调用导入的函数功能，调用时不需要写模块名可直接调用。

> ### from····import* 语句

把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：

```python
from 模块名 import *
```

> ### 对导入模块重命名

在导入模块时使用 `as` 关键字创建别名。

```python
import 模块名 as 别名

```

当导入的模块名字太长时，可以对其进行重命名，使我们在调用时更加方便。

- **模块的下载（pip）:**

>
> 在我们使用第三方模块时，我们需要对其进行下载，下载完成后我们才能进行导入使用，建议在命令行cmd中使用pip进行下载。
>
> pip 是 Python 包管理工具，该工具提供了对 Python 包的查找、下载、安装、卸载的功能



- **dir（）函数:**

> 内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:

```python
>>> import sys
>>> dir(sys)
['__displayhook__', '__doc__', '__excepthook__', '__loader__', '__name__',
 '__package__', '__stderr__', '__stdin__', '__stdout__',
 '_clear_type_cache', '_current_frames', '_debugmallocstats', '_getframe',
 '_home', '_mercurial', '_xoptions', 'abiflags', 'api_version', 'argv',
 'base_exec_prefix', 'base_prefix', 'builtin_module_names', 'byteorder',
 'call_tracing', 'callstats', 'copyright', 'displayhook',
 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix',
 'executable', 'exit', 'flags', 'float_info', 'float_repr_style',
 'getcheckinterval', 'getdefaultencoding', 'getdlopenflags',
 'getfilesystemencoding', 'getobjects', 'getprofile', 'getrecursionlimit',
 'getrefcount', 'getsizeof', 'getswitchinterval', 'gettotalrefcount',
 'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',
 'intern', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path',
 'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'ps1',
 'setcheckinterval', 'setdlopenflags', 'setprofile', 'setrecursionlimit',
 'setswitchinterval', 'settrace', 'stderr', 'stdin', 'stdout',
 'thread_info', 'version', 'version_info', 'warnoptions']

```

- **Python中name属性:**

> 在Python中用来判断文件执行的时候是为执行文件还是模块

```python
print(__name__)
"""
 当文件有该语句时 ， 结果输出为__main__的话说明该文件
为执行文件，当输出结果为一个模块名（文件名）就说明这个文
件被当作一个模块使用
"""
```


**说明：** 每个模块都有一个__name__属性，当其值是'__main__'时，表明该模块自身在运行，否则是被引入。

说明：**__name__** 与 **__main__** 底下是双下划线， _ _ 是这样去掉中间的那个空格。

判断当前文件是否为执行文件：

```python
if __name__ == '__main__':
    pass
```

该程序块仅在该模块自身运行时执行。	

## 包

**目录结构：**

> - 包的介绍
> - 包的使用

- **包的介绍：**

> 包：将功能模块放在一个文件夹里面 ， 将不同功能的模块进行分组管理
>
> 在PyCharm中创建一个包==>new ==> Python Package。
>
> 包创建之后会自动产生__init__.py文件，该文件的内容就是包内模块的说明，在导包的时候这个文件会一起自动自行

- **包的使用:** 

> from  包名 import 模块名

```python
from 包名 import 模块名
 
# 导入包内模块的单个功能
from 包名.模块名 import 函数名
```
